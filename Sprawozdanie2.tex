\documentclass{article}
\title{Sprawozdanie 2 \\ Testowanie opracowanej metody heurystycznej}
\date{2018-06-01}
\author{Mateusz Babiaczyk, Bartosz Nawrotek}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{graphicx}
\usepackage{float}
\graphicspath{ {Wykresy/} }
\usepackage{geometry}
 \geometry{
 a4paper,
 total={170mm,257mm},
 left=20mm,
 top=20mm,
 }

\begin{document}
\maketitle
\section{Zmiany w algorytmie}  
Po zaimplementowaniu algorytmu i zauważeniu jego słabych osiągnięć, zdecydowano by wprowadzić zmiany w zastosowanym podejściu algorytmicznym. Poniżej w kilku sekcjach omówiono te cześci algorytmu, które zostały zastąpione.
\subsection{Kodowanie}
Zmiana w kodowaniu polega na traktowaniu osobnika jako cykliczny, spowodowało to że każdy osobnik jest zbiórem rozwiązań z przesuniętym początkiem o jeden oligonukleotyd. Nie pogorszyło to złożoności obliczeniowej wyznaczania funkcji celu, która pozostała równa $O(n)$, gdzie $n$ jest długością osobnika. Pozwoliło natomiast na traktowanie jednego rozwiązania jako zbioru $n$ różnych rozwiązań i korzystania z tej części osobnika o najlepszym przystosowaniu.
\subsection{Mutacje}
W funkcji odpowiedzialnej za dokonanie mutacji osobnika została zastosowana odrębna idea ze względu na to, że rozwiązania pozostawały w minimach lokalnych. Przyjęto konwencję, w której każdy z oligonukleotydów ma wygenerowane koło fortuny. Dla koła fortuny oligonukleotydu $A$, każdy z oligonukleotydów otrzymuje wycinek koła w zależności od funkcji kosztu między nim a osobnikiem $A$ (Dla kosztu maksymalnego, nie otrzymuje wycinka). Gdy następuje mutacja osobnika wybierany jest oligoukleotyd $a$ o największym koszcie będącym sumą kosztów z sąsiednimi oligonukleotydami oraz losowany jest oligonukleotyd $b$ przy użyciu wygenerowanego koła fortuny przed którym umieszczany zostaje oligonukleotyd $a$. Dzięki temu algorytm przemieszcza oligonukleotyd o najgorszym dopasowaniu w co najmniej tak dobre miejsce preferując miejsca lepszego dopasowania.
\subsection{Krzyżowanie}
Krzyżowanie zaczyna się w dokładnie taki sam sposób jak w pierwotnym algorytmie, a mianowicie od pewnego wylosowanego przedziału przepisuje się oligonukleotydy do nowo tworzonego osobnika (kopiuje wycinek i wkleja go do nowego osobnika) z wybranego osobnika z populacji rodzicielskiej. Następnie uzupełniany jest koniec osobnika wartościami z innego osobnika z populacji rodzicielskiej, uważając oczywiście by dany oligonukleotyd nie został powtórzony. W ten sam sposób zostaje uzupełniony początek osobnika z nowej populacji. \\ Wszystkie oligonukleotydy które nie zostały dodane wstawiane są, w miejsca w których ich koszt będzie najmniejszy. Motywacją było przyspierzenie zbieżności algorytmu oraz zachowanie losowości dzięki losowemu doborowi punktów krzyżowania. Tym samy dając lepsze rozwiązania w krótszym czasie przetwarzania jak i dając możliwość na opuszczenie minimów lokalnych.
\section{Testy}
\subsection{Wyniki algorytmu dla błędów negatywnych, losowych}
\begin{figure}[H]
\includegraphics[width=0.5\textwidth]{neg-los1.png}
\includegraphics[width=0.5\textwidth]{neg-los-greedy1.png}
\includegraphics[width=0.5\textwidth]{neg-los2.png}
\includegraphics[width=0.5\textwidth]{neg-los-greedy2.png}
\includegraphics[width=0.5\textwidth]{neg-los3.png}
\includegraphics[width=0.5\textwidth]{neg-los-greedy3.png}
\includegraphics[width=0.5\textwidth]{neg-los4.png}
\includegraphics[width=0.5\textwidth]{neg-los-greedy4.png}
\caption{Porównanie algorytmu dla błędów negatywnych, losowych bez oraz z wykorzystanym osobnikiem wygenerownym przez algorytm zachłanny w zależności od ilości iteracji}
\end{figure}
\begin{figure}[H]
\includegraphics[width=0.5\textwidth]{Czasneg-los1.png}
\includegraphics[width=0.5\textwidth]{Czasneg-los-greedy1.png}
\includegraphics[width=0.5\textwidth]{Czasneg-los2.png}
\includegraphics[width=0.5\textwidth]{Czasneg-los-greedy2.png}
\includegraphics[width=0.5\textwidth]{Czasneg-los3.png}
\includegraphics[width=0.5\textwidth]{Czasneg-los-greedy3.png}
\includegraphics[width=0.5\textwidth]{Czasneg-los4.png}
\includegraphics[width=0.5\textwidth]{Czasneg-los-greedy4.png}
\caption{Porównanie algorytmu dla błędów negatywnych, losowych bez oraz z wykorzystanym osobnikiem wygenerownym przez algorytm zachłanny w zależności od czasu przetwarzania}
\end{figure}
Jak widać, dla błędów negatywnych losowych algorytm otrzymuje rozwiązanie o średniej dokładności 90\%. W algorytmie z początkowym algorytmem zachłannym (wykresy po prawej) widać że otrzymuje on średnio lepsze wyniki z prostej przyczyny początkowego uszeregowania które ma bardzo dobrą jakość rozwiązania. Powodem tego są rodzaje testów, które bardzo dobrze są rozwiązywane przez algorytm zachłanny. Nie zmienia to jednak faktu, że algorytm bez początkowego rozpoczęcia zachłannego uzyskuje podobne wyniki, a funkcja poprawnie zbiega do celu.
\subsection{Wyniki algorytmu dla błędów negatywnych na końcach sekwencji}
\begin{figure}[H]
\includegraphics[width=0.5\textwidth]{neg-pow1.png}
\includegraphics[width=0.5\textwidth]{neg-pow-greedy1.png}
\caption{Porównanie algorytmu dla błędów negatywnych na końcach sekwencji bez oraz z wykorzystanym osobnikiem wygenerownym przez algorytm zachłanny w zależności od ilości iteracji}
\end{figure}
\begin{figure}[H]
\includegraphics[width=0.5\textwidth]{Czasneg-pow1.png}
\includegraphics[width=0.5\textwidth]{Czasneg-pow-greedy1.png}
\caption{Porównanie algorytmu dla błędów negatywnych na końcach sekwencji bez oraz z wykorzystanym osobnikiem wygenerownym przez algorytm zachłanny w zależności od czasu przetwarzania}
\end{figure}
W przypadku  błędów negatywnych na końcach sekwencji wyniki są zbliżone do błędów negatywnych losowych i zachowują taką samą własność.
\subsection{Wyniki algorytmu dla błędów pozytywnych, losowych}
\begin{figure}[H]
\includegraphics[width=0.5\textwidth]{poz-los1.png}
\includegraphics[width=0.5\textwidth]{poz-los-greedy1.png}
\includegraphics[width=0.5\textwidth]{poz-los2.png}
\includegraphics[width=0.5\textwidth]{poz-los-greedy2.png}
\caption{Porównanie algorytmu dla błędów pozytywnych, losowych bez oraz z wykorzystanym osobnikiem wygenerownym przez algorytm zachłanny w zależności od ilości iteracji}
\end{figure}
\begin{figure}[H]
\includegraphics[width=0.5\textwidth]{Czaspoz-los1.png}
\includegraphics[width=0.5\textwidth]{Czaspoz-los-greedy1.png}
\includegraphics[width=0.5\textwidth]{Czaspoz-los2.png}
\includegraphics[width=0.5\textwidth]{Czaspoz-los-greedy2.png}
\caption{Porównanie algorytmu dla błędów pozytywnych, losowych bez oraz z wykorzystanym osobnikiem wygenerownym przez algorytm zachłanny w zależności od czasu przetwarzania}
\end{figure}
Dla błędów pozytywnych losowych nasz algorytm nie działa już tak dobrze. Jak widać algorytm bez początku zachłannego uzyskuje średnie wyniki w okolicach 60\%. Jest do dość słaby wynik. Dodatkowo algorytm z początkiem zachłannym tylko pogarsza swoje wyniki po lepszym wyniku zachłannym, żeby ostatecznie dojść do prawie takiego samego wyniku jak algorytm bez początku zachłannego.  
\subsection{Wyniki algorytmu dla błędów pozytywnych, na końcach sekwencji}
\begin{figure}[H]
\includegraphics[width=0.5\textwidth]{poz-oli1.png}
\includegraphics[width=0.5\textwidth]{poz-oli-greedy1.png}
\includegraphics[width=0.5\textwidth]{poz-oli2.png}
\includegraphics[width=0.5\textwidth]{poz-oli-greedy2.png}
\caption{Porównanie algorytmu dla błędów pozytywnych na końcach sekwencji bez oraz z wykorzystanym osobnikiem wygenerownym przez algorytm zachłanny w zależności od ilości iteracji}
\end{figure}
\begin{figure}[H]
\includegraphics[width=0.5\textwidth]{Czaspoz-oli1.png}
\includegraphics[width=0.5\textwidth]{Czaspoz-oli-greedy1.png}
\includegraphics[width=0.5\textwidth]{Czaspoz-oli2.png}
\includegraphics[width=0.5\textwidth]{Czaspoz-oli-greedy2.png}
\caption{Porównanie algorytmu dla błędów pozytywnych na końcach sekwencji bez oraz z wykorzystanym osobnikiem wygenerownym przez algorytm zachłanny w zależności od czasu przetwarzania}
\end{figure}
Ostatnią kategorią są błędy pozytywne z przekłamaniami na końcach oligonukleotydów. Jak widać radzi on sobie odrobinę lepiej niż dla błędów pozutywnych losowych, dodatkowo algorytm z rozpoczęciem zachłannym nie maleje aż tak bardzo (algorytm zachłanny ma większe problemy z optymalnym ustawieniem i jego wykonanie nie powoduje od razu ustawienia pierwszej iteracji na wysokości 90-95\%, a nieco niżej na 70-80\%).
\section{Wnioski}
\end{document}


